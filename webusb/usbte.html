<!DOCTYPE html>
<html>
<!-- USBTE -->
<!-- See: https://wicg.github.io/webusb/ -->
<!-- See: https://wicg.github.io/serial/ -->

<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">

    <title>USBTE</title>
    <style>

    </style>
</head>

<body onload='Body()'>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL"
        crossorigin="anonymous"></script>
    <script>
        function on_slider_change() {
            var slider = document.getElementById("size_slider");
            console.log(" slider change " + slider.value)

            var output = document.getElementById("hand");
            output.setAttribute("width", "" + slider.value / 2 + "%")
        }

    </script>
    <h1>Web USB Terminal Emulator</h1>
    <div class="slidecontainer" width="100%"">
        <input type="range" min="1" max="100" value="50" class="slider" id="size_slider" onchange="on_slider_change()"
        onmousemove="on_slider_change()">
        <span id="currentValue">0</span>
    </div>
    <div class="text-center">
        <img src="hand.jpeg" alt="USBTE" width="10%" class="center" id="hand">
    </div>
    <!-- For bulk endpoint access, CpuStick vendorId/productId 0x0403/0xa660 with cdc/acm class/subclass 02/02 is replaced with FF/00 -->

    Optional filter to
    VID: <input id='vendorId' name='vendorId' size='6' value="0x1CBE" />
    PID: <input id='productId' name='productId' size='6' value="0x00FD" />

    <p>
        Select:
        <button type='button' class="btn btn-primary" onclick="Comm();">COM</button>

        or
        <!-- bulk endpoint from device -->
        epin: <input id='epin' name='epin' size='1' value='2' />
        <!-- bulk endpoint to device -->
        epout: <input id='epout' name='epout' size='1' value='3' />
        and:
        <button type='button' class="btn btn-primary" onclick="Usb();">USB</button>

    <pre id='results'></pre>

    <input id='command' name='command' disabled='true' autocomplete='off' autocorrect='off' autocapitalize='off'
        spellcheck='false' />
    <br>
    <button type='button' class="btn btn-primary" onclick='Enter();'>Enter</button>
    <button type='button' class="btn btn-primary" onclick='Send("\0x0003");'>Ctrl-C</button>
    <button type='button' class="btn btn-primary" onclick='Send("\0x0004");'>Ctrl-D</button>
    <button type='button' class="btn btn-primary" onclick='Paste();'>Paste</button>
    <button type='button' class="btn btn-primary" onclick='Clear();'>Clear</button>

    <p id='copyright'>
        <a href=https://github.com/rtestardi/usbte target=_blank>github.com/rtestardi/usbte</a>
        &nbsp;&nbsp;&nbsp;
        <a href=https://github.com/rtestardi/StickOS target=_blank>github.com/rtestardi/StickOS</a>
        &nbsp;&nbsp;&nbsp;
        <a href=https://rtestardi.github.io/StickOS target=_blank>rtestardi.github.io/StickOS</a>

        <script>
            'use strict';

            var comm;
            var reader;
            var writer;
            var usb;
            var enc = new TextEncoder();
            var dec = new TextDecoder();
            var lines = [];
            var cursor = 0;
            var first = false;

            // the user loaded the webpage; set up keyboard listeners
            function Body() {
                document.body.addEventListener("keydown", function (event) {
                    if ((event.keyCode === 67 || event.keyCode === 68) && event.ctrlKey && document.activeElement === document.getElementById("command")) {
                        // ctrl-c or ctrl-d in command line -- flow thru to device
                        event.preventDefault();
                        event.stopPropagation();
                        Send(String.fromCharCode(event.keyCode - 64));
                    }
                    if (event.keyCode === 13) {
                        // enter -- run the command line
                        event.preventDefault();
                        Enter();
                    }
                    if (event.keyCode === 40) {
                        // down arrow -- recall a newer command line
                        event.preventDefault();
                        UpDown(false);
                    }
                    if (event.keyCode === 38) {
                        // up arrow -- recall an older command line
                        event.preventDefault();
                        UpDown(true);
                    }
                })
            }

            // the user wants to connect to a USB device's bulk endpoints directly
            async function Usb() {
                var filter = {};
                if (document.getElementById("vendorId").value != "") {
                    filter["vendorId"] = document.getElementById("vendorId").value;
                    if (document.getElementById("productId").value != "") {
                        filter["productId"] = document.getElementById("productId").value;
                    }
                }

                try {
                    usb = await navigator.usb.requestDevice({ filters: [filter] });
                    await usb.open();
                    await usb.selectConfiguration(1);
                    await usb.claimInterface(1);

                    setTimeout(Receive, 10);

                    document.getElementById("command").disabled = false;
                    document.getElementById("command").focus();
                } catch (err) {
                    document.getElementById("results").innerHTML += err.message.replace(/</g, '&lt;').replace(/>/g, '&gt;') + "\r";
                }
            }

            // the user wants to connect to an emulated COM port
            async function Comm() {
                var filter = {};
                if (document.getElementById("vendorId").value != "") {
                    filter["usbVendorId"] = document.getElementById("vendorId").value;
                    if (document.getElementById("productId").value != "") {
                        filter["usbProductId"] = document.getElementById("productId").value;
                    }
                }

                if ('serial' in navigator) {
                    try {
                        comm = await navigator.serial.requestPort("usbVendorId" in filter ? { filters: [filter] } : {});
                        await comm.open({ baudRate: 115200, bufferSize: 64 });
                        reader = comm.readable.getReader();
                        writer = comm.writable.getWriter();

                        setTimeout(Receive, 10);

                        document.getElementById("command").disabled = false;
                        document.getElementById("command").focus();
                    } catch (err) {
                        document.getElementById("results").innerHTML += err.message.replace(/</g, '&lt;').replace(/>/g, '&gt;') + "\r";
                    }
                } else {
                    document.getElementById("results").innerHTML +=
                        `The Web serial API needs to be enabled in your browser thru:
   - <a href=edge://flags/#enable-experimental-web-platform-features>edge://flags/#enable-experimental-web-platform-features</a>
   - <a href=chrome://flags/#enable-experimental-web-platform-features>chrome://flags/#enable-experimental-web-platform-features</a>
   - <a href=opera://flags/#enable-experimental-web-platform-features>opera://flags/#enable-experimental-web-platform-features</a>
`;
                }
            }
            var rest = ""
            function collect_line(str) {
                var output = ""
                var length = str.length
                var lf_pos = str.indexOf('\n')
                if (lf_pos == -1) {
                    rest += str
                    output = ""
                } else {
                    output = rest + str.substring(0, lf_pos)
                    rest = str.substring(lf_pos)
                }
                console.log("collect_line " + output)
                return output
            }

            // receive a string from the device
            async function Receive() {
                var result;
                var str;
                if (usb) {
                    result = await usb.transferIn(document.getElementById("epin").value, 64);
                    str = dec.decode(result.data.buffer);
                } else {
                    result = await reader.read();
                    str = dec.decode(result.value);
                }
                str = collect_line(str)
                if (str.length > 0) {
                    try {

                        var v = JSON.parse(str.substring(0, str.indexOf(']') + 1))
                        console.log(v)
                        var output = document.getElementById("hand");
                        output.setAttribute("width", "" + v[6] / 20 + "%")
                    } catch (e) {
                        console.log(e)
                    }
                }
                if (str.match(/\033[[]2J/)) {
                    // clear screen on cls  XXX -- misses fragmented escape
                    Clear();
                } else {
                    //          document.getElementById("results").innerHTML += str.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '');
                }
                document.getElementById("command").scrollIntoView();
                setTimeout(Receive, 10);
            }

            // send a string to the device
            async function Send(str) {
                if (usb) {
                    await usb.transferOut(document.getElementById("epout").value, enc.encode(str).buffer);
                } else {
                    await writer.write(enc.encode(str).buffer);
                }
                document.getElementById("command").value = "";
                document.getElementById("command").focus();
            }

            // the user clicked the Enter button; run the user command line
            async function Enter() {
                var str = document.getElementById("command").value;
                if (str.length && (!lines.length || str != lines[lines.length - 1])) {
                    lines.push(str);
                }
                Send(str + "\r");
                first = true;
            }

            // the user typed up-arrow or down-arrow to recall an older or newer command line
            function UpDown(up) {
                if (first && up) {
                    // an initial up-arrow recalls the last hyperlink from the results history
                    cursor = 0;
                }
                if (lines.length) {
                    // recall the requested hyperlink from the results history to the equation line
                    if (up) {
                        // older
                        cursor = (cursor + lines.length - 1) % lines.length;
                    } else {
                        // newer
                        cursor = (cursor + 1) % lines.length;
                    }
                    document.getElementById("command").value = lines[cursor];
                    first = false;
                }
            }

            // the user clicked the Paste button; paste the clipboard into the command line
            async function Paste() {
                var text = await navigator.clipboard.readText();
                Send(text + "\r");
            }

            // the user clicked the Clear button; clear the command, results, and history list
            async function Clear() {
                document.getElementById("results").innerHTML = "";
                document.getElementById("command").value = "";
                document.getElementById("command").focus();
                //lines = [];
            }

        </script>
</body>

</html>